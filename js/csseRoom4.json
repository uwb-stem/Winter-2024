{
    "csse": [
        {
            "time": "1:00-1:15",
            "projectId": "csse-4-100",
            "title": "Automatic Mock Code Generation",
            "studentName": "Furqan Kassa",
            "studentMajor": "CSSE",
            "projectType": "Sponsored Internship",
            "facultyAdvisor": "Dr. Min Chen",
            "posterLink": "./posters/csse/kassafurqanahmed_4025068_117567100_Capstone_Winter2024.png",
            "abstract": "Over the fall quarter, I worked as a Software Engineer Intern at Amazon Robotics. I was a part of the core team in the Virtual Systems organization. My team was responsible for running robotic simulations to simulate hardware, software, and human interactions within fulfilment centers. The purpose of these simulations where so teams wouldn’t have to build prototypes and could simply simulate the impact. When it comes to these simulation models, it uses AWS services or mock those services within simulation boundary. However, the demand for simulation models rose over time which doubled the effort from developers. To reduce redundant effort, I investigated large language models (LLM) offered by AWS to automate the code generation for these simulation models.\n\n Initially, I focused on prompt engineering since we weren’t allowed to use source code. To provide context for these LLMs on what a mock service is, I wrote mock code for a simple DynamoDB service that read and wrote the name of LLMs. I was able to reproduce that same service by feeding the LLMs context on what the service does, however, the console where you interact with the LLMs had no concept of sessions. Thus, having to redo all that prompt engineering and feeding the same context all over again. To better provide context, I navigated towards a framework called LangChain (LC) to interface with these LLMs. However, this framework had deprecated modules of saving prompt history and with 3rd party model legal policies, it was difficult to continue experimenting.\n\n While adhering to the original effort of reducing developer effort, I pivoted towards helping developers debug by simplifying the navigation through the online guide on how to create simulations, specifically using LLMs through a chatbot system. I created a chatbot that utilized Retrieval Augmented Generation which is a process in the LC framework where it loads external resources like the guide, splits down the texts, stores those chunks into a vector store to convert those chunks into vector representations and make them searchable. I worked on the UI for the chatbot and integrated into the online guide, allowing for developers and other users to ask specific questions about simulations rather than search through the whole guide manually. My internship experience elevated my technical skills, taught me lessons on how to navigate team spaces and practices of Software Development. "
        },        {
            "time": "1:15-1:30",
            "projectId": "csse-4-115",
            "title": "Blackfoot: E-Learning App",
            "studentName": "Yixin Zhang",
            "studentMajor": "CSSE",
            "projectType": "Faculty research",
            "facultyAdvisor": "Dr. Min Chen",
            "posterLink": "./posters/csse/Yixin Zhang.png",
            "abstract": "This capstone project, under faculty guidance, is dedicated to creating an online Blackfoot language learning platform. The primary goal is to provide an engaging and interactive virtual learning environment that blends fun with cultural and linguistic education. The platform is designed to facilitate student interaction, simplify teacher content management, and ensure administrative oversight, functioning as a digital classroom for collaborative learning.\n\n The project addresses the urgent need for an accessible and effective means to learn and preserve the Blackfoot language, an important aspect of indigenous heritage. Its architecture features a user-friendly front end, a robust backend application, and a secure data layer for a seamless experience.\n\n My role centered on developing the administrative panel using React for the front end, Node.js for backend functionalities, and PostgreSQL for the database. I was responsible for creating an admin panel to manage teacher accounts, oversee content and course verification, and track website statistics, ensuring system integrity. A key achievement was deploying the admin panel on AWS for reliable and scalable hosting, and aiding in the setup of teacher and student components on AWS.\n\n This project is significant in its potential to transform indigenous language learning. By offering an immersive platform, it not only aids in language learning but also helps preserve cultural heritage. The expected result is a versatile, user-friendly platform setting a new online language learning standard.\n\n In summary, this project marks a crucial step in digitizing and revitalizing indigenous languages. It serves as a replicable model for other endangered languages and demonstrates how modern e-learning technology can be used effectively and sensitively in language education. "
        },        {
            "time": "1:30-1:45",
            "projectId": "csse-4-130",
            "title": "Project Discovery 3D Unity Engine Video Game Prototype",
            "studentName": "Jesse Manley",
            "studentMajor": "CSSE",
            "projectType": "Individual project",
            "facultyAdvisor": "Dr. Min Chen",
            "posterLink": "./posters/csse/manleyjesse_4086343_117391793_Manley_CSS497_Poster.png",
            "abstract": "The goal of my project was to explore game development as a career and to get exposure to the many interdisciplinary fields required in video game development. Although I have some experience working on individual game systems, I’ve never created anything that brought all the systems together into something holistic. I wanted to be able to answer questions such as:\n\n What parts of development do I like or not like?\n What parts of development am I good or bad at?\n How much time and skill do certain tasks require?\n Is this something I can do myself or will I need help?\n Is game development a feasible career choice for me?\n\n My approach to answering these questions was to create a video game prototype which contained basic systems that are common in most modern video games and would also touch on several different fields of development. I used the Unity game engine and several other programs that were necessary for creating 3D objects and art assets. Each week I focused on one or two major systems that were incorporated into the larger project. Some weekly goals included: character control, animation, interaction, UI, audio, environments, and saving/loading.\n\n The outcome of my approach was a video game prototype that I’m very happy with and, more importantly, a great deal of learning new skills and answers to my questions posed above. I discovered that, rather than being an obstacle, the interdisciplinary nature of game development suits me very well. It allows me to stay engaged with a project and not get burned out on any one aspect of development because I can pivot to other tasks and come back with a fresh perspective and greater motivation. I’m always learning something new and I get to satisfy both my engineering side and my creative side. Although there are some tasks I’m more skilled at than others and some tasks that I enjoy more than others, I enjoy the overall process and I feel confident that I could be successful if I chose game development as a career."
        },        {
            "time": "1:45-2:00",
            "projectId": "csse-4-145",
            "title": "The Garlic Games: An Advanced Online Multiplayer Game Platform",
            "studentName": "Ben Schipunov",
            "studentMajor": "CSSE",
            "projectType": "Individual project",
            "facultyAdvisor": "Dr. Robert Dimpsey",
            "posterLink": "./posters/csse/schipunovben_4283417_117568522_CAPSTONE_POSTER_IMAGE_FINAL.png",
            "abstract": "The Garlic Games is an online multiplayer game platform I have been developing as an individual project since November of 2021. It is made for users to have fun and to easily play various multiplayer games in any situation, whether over the internet or in a social setting. When developing this site, I aimed for it to fill gaps, have features not included in other online game sites, and have the flexibility further to improve the social entertainment experience for various audiences.\n\n This development phase aimed to transform this project the most since its inception by switching to more efficient programming languages, allowing developers to manage the platform more efficiently and resulting in a more delightful experience for players. Previously, this platform relied on more traditional development practices, which I had used before acquiring knowledge of new programming languages and tools.\n\n By the end of this development phase, I had met the most foundational software requirements by switching to a modern development framework, improving the project structure, and adding a user account system allowing users to use accounts from existing providers. These requirements established a baseline on how this project will continue to grow by adding more features.\n\n The project is significant in how I made each feature flow seamlessly in the system for both users and developers. For instance, while a standard credentials-based account system did suffice, I also wanted to add the option for users to log in using accounts from other providers, a standard across many other sites. While it may be easy nowadays to implement features like these, I implemented them in a way that connects seamlessly with the site, which took many iterations to execute as desired. "
        },        {
            "time": "2:00-2:15",
            "projectId": "csse-4-200",
            "title": "Optimization, Planning, And Videos Made Of Letters",
            "studentName": "Dhimitri Mano",
            "studentMajor": "CSSE",
            "projectType": "Individual project",
            "facultyAdvisor": "Dr. Robert Dimpsey",
            "posterLink": "./posters/csse/manodhimitri_4024309_117617087_Mano - Capstone Poster-1.png",
            "abstract": " My ANSI4 project was an attempt to create a video file that is comprised of nothing but characters (symbols such as letters, numbers, punctuation marks, and anything else that can be displayed by a terminal). I chose this project to work on because of two factors. The first was the growing average file size for programs and media. As hardware becomes better, operations and memory become less expensive. However, this improvement of hardware has led many programmers to abandon age-old optimization practices, leading to final file sizes that are close to a hundred gigabytes and far too expensive for old or lower-end hardware to render. The second was the fact that many systems are terminal-only, and thus can only display characters and have no ability to play more traditional video file formats like the mp4 format. These factors led to my creation of the ANSI4 file format, which stores a video as characters, as well as two programs, alongside two helper programs, that allow the user to convert an mp4 file to an ANSI4 file and play it in their own system’s terminal. It is a file type that is optimized enough for even lower-end machines to be able to play it. I wanted to create a file type and a set of algorithms that have the best combination of efficient time- and space- complexity possible, and I wanted to do it with as little outside help as possible.\n\n The result of this project was a plateau. Mp4 files can only be condensed so much when put in a compressed archive, since their file types already use this method of compressing as well as possible without losing any data or being too slow to unload, and the same is true of ANSI4 files. However, the files and the algorithms are still several times more efficient than mp4 files since they hold much less data, storing individual characters that represent pixel clumps instead of three or more values for every pixel. The algorithms are also quite efficient, utilizing many methods to make them efficient in all areas. Because of these reasons, the ANSI4 file format is quite significant, as it allows even systems with very limited storage space, processing power, and/or display capabilities to store and play videos that they otherwise wouldn’t be able to. "
        },        {
            "time": "2:15-2:30",
            "projectId": "csse-4-215",
            "title": "Autograder for CSS 342 & CSS 343",
            "studentName": "Jeffrey Caruso",
            "studentMajor": "CSSE",
            "projectType": "Faculty research",
            "facultyAdvisor": "Dr. Yusuf Pisan",
            "posterLink": "./posters/csse/carusojeffrey_4124916_117603022_full size 48x36.jpg",
            "abstract": "In programming classes, such as 342 Data Structures and Algorithms (DSA) I and 343 DSA II, testing the code is an important component in reaching the learning objectives of knowing how to develop and test code. A significant obstacle to this goal is the time needed to get feedback on their code to students. This considerable time investment for instructors and long delays for students is suboptimal for both parties and the primary focus of improvement for this project with the overall goal to enhance learning outcomes moving forward.\n\n The automated grading system uses several key enabling technologies in line with modern software development principles. The primary technologies used are GitHub Actions, GitHub Classroom, and Google Test, which from the student’s perspective appears like this. Students begin with accepting using GitHub classroom, then cloning the project starter repository, and writing some code. They can test locally with a simple command line entry starting a script which will launch automated testing locally on a Docker container mirroring the environment of the CSS Linux lab. Once students are ready, they commit and push their solution to GitHub. GitHub Actions detects the push and automatically builds and then tests their code with Google Test. Once execution is complete, students can see which tests passed and failed. Finally, the instructor can see the student results with GitHub classroom, this facilitates much faster grading by having the bulk of the work already done.\n\n Instructors can now grade students’ work quickly as most of it will already be graded. The instructor just needs to assign appropriate partial credit to failing tests. This system makes grading take a fraction of the time it took before this system. This enables the professor and/or TA to have more time to spend on other enriching activities for students. Students can now feel confident they have done their work correctly once all the tests pass. They will also receive nearly instant feedback on their code with information about what went wrong, and what was expected to happen. This will provide a great head start in finding the bug in their code and understanding how to fix it.\n\n Overall, this capstone project will save time and reduce stress for instructors and students, enabling enhanced learning outcomes for many years to come. "
        },        {
            "time": "2:30-2:45",
            "projectId": "csse-4-230",
            "title": "Dermi AI",
            "studentName": "Srikar Chava",
            "studentMajor": "CSSE",
            "projectType": "Group Project",
            "facultyAdvisor": "Dr. Wooyoung Kim",
            "posterLink": "./posters/csse/chavasrikar_LATE_4140195_117629053_Group 1000004306 (1).png",
            "abstract": " The burgeoning field of digital health technologies has significantly transformed patient care, offering novel approaches to diagnosis and treatment. Among these innovations, artificial intelligence (AI) plays a pivotal role, particularly in dermatology, where visual assessment is fundamental. This project introduces \"Dermi,\" an AI-enabled dermatology mobile app designed to provide users with condition diagnoses by analyzing uploaded images of skin issues. This abstract delineates the project's scope, methodology, outcomes, and significance.\n\n The motivation behind Dermi stems from the global challenge of accessing dermatological care. With a limited number of specialists and increasing demand, many patients face delays in diagnosis and treatment, potentially exacerbating conditions. Dermi aims to bridge this gap by enabling preliminary assessments through a user-friendly mobile interface.\n\n The project's core involved developing a robust AI model trained on a vast dataset of dermatological images, annotated with diagnoses by experts. This model employs deep learning techniques to analyze user-uploaded pictures, identifying patterns and features indicative of specific skin conditions. The development process encompassed data collection, preprocessing, model training, and integration into a mobile app platform.\n\n Upon deployment, Dermi demonstrated a high accuracy rate in condition diagnosis, offering users immediate insights into potential skin issues. The app includes a disclaimer advising users to seek professional medical advice for a definitive diagnosis and treatment plan.\n\n The significance of Dermi lies in its potential to democratize dermatological care, making preliminary assessments accessible to a broader population. It serves as a valuable tool for early detection, empowering users with knowledge about their skin health. Furthermore, Dermi contributes to the digital health landscape by showcasing the practical applications of AI in enhancing patient care.\n\n In conclusion, Dermi exemplifies the transformative impact of AI in healthcare, offering a scalable solution to the challenges of dermatological diagnosis. Its development and deployment underscore the potential of digital tools in augmenting patient care and accessibility, marking a significant advancement in telemedicine. "
        },        {
            "time": "2:45-3:00",
            "projectId": "csse-4-245",
            "title": "SQL Server's \"FOR JSON\" in Postgre SQL",
            "studentName": "Kuzey Gok",
            "studentMajor": "CSSE",
            "projectType": "Sponsored Internship",
            "facultyAdvisor": "Dr. Michael Stiber",
            "posterLink": "./posters/csse/gokkuzey_LATE_4142166_117622173_capstoneposter.jpg",
            "abstract": "The capstone project, undertaken as part of my internship at AWS, focused on the implementation of the “FOR JSON” feature in Aurora’s PostgreSQL. This feature is exclusive to SQL Server, and this endeavor aimed to bridge the gap between the two distinct database technologies to enhance PostgreSQL’ s functionality and offer greater flexibility to users.\n\n Babelfish by AWS is a pioneering technology that allows PostgreSQL to understand queries from applications written for Microsoft SQL Server. This feature is part of Amazon’s larger effort to make database migration easier and more seamless, especially for business looking to move from propriety database systems to more open and cost-effective solutions, like Aurora PostgreSQL by Amazon. Babelfish did not have full support for “FOR JSON”, where it only allowed single JSON layered “FOR JSON PATH” outputs, and no support for “FOR JSON AUTO”.\n\n The project commenced with an analysis of SQL Server’s “FOR JSON” implementation, involving a deep dive into Microsoft’s documentation to understand its operational intricacies and reviewing customer queries. This phase was crucial for replication the feature’s functionality in PostgreSQL with high fidelity. Subsequent efforts involved setting up a database instance to serve as testing grounds. Here I explored the nuances of “FOR JSON” commands by analyzing their behaviors.\n\n The project’s core comprised the development of a design document that outlined the current state of “FOR JSON” in Babelfish, proposed solutions, and enhancing its compatibility and performance. This phase of the project included an in-depth exploration of PostgreSQL’s JSON libraries and the adaptation of Jsonb for potential performance improvements.\n\n As the project progressed, we encountered technical complexities related to Jsonb, datatype handling, and the integration of PostgreSQL’s HTAB library for hashing. Jsonb experienced issues with keeping order of the items inside its JSON object, so we pivoted to using JsonBValue, the building block of Jsonb. These challenges were systematically addressed through continuous research, collaboration with coworkers, and debugging. \n\n The culmination of the project saw the successful implementation and testing of “FOR JSON PATH”. With the remaining time, A detailed design and review of “FOR JSON AUTO” was culminated to ensure the robustness of the implementation, align it with PostgreSQL’s broader objectives, and solve pre-requisites that made it differ from “FOR JSON PATH”.\n\n This capstone project facilitated the integration of a key SQL Server into Amazon Aurora’s PostgreSQL and underscored the importance of cross-technology compatibility in database technologies. "
        }
    ]
}